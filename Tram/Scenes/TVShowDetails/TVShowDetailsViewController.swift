//
//  TVShowDetailsViewController.swift
//  Tram
//
//  Created by Roman Abuzyarov on 19.03.2018.
//  Copyright (c) 2018 Tram, inc.. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol TVShowDetailsDisplayLogic: class
{
    func displayData(viewModel: TVShowDetails.DataFilling.ViewModel)
    func displayShowLists(viewModel: TVShowDetails.ShowLists.ViewModel)
    func displayEpisodeLists(viewModel: TVShowDetails.EpisodeLists.ViewModel)
}

class TVShowDetailsViewController: UIViewController, TVShowDetailsDisplayLogic
{
    var interactor: TVShowDetailsBusinessLogic?
    var router: (NSObjectProtocol & TVShowDetailsRoutingLogic & TVShowDetailsDataPassing)?
    
    @IBOutlet weak var collectionView: UICollectionView!
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)
    {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder)
    {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: Setup
    
    private func setup()
    {
        let viewController = self
        let interactor = TVShowDetailsInteractor()
        let presenter = TVShowDetailsPresenter()
        let router = TVShowDetailsRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    
    // MARK: Routing
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?)
    {
        if let scene = segue.identifier {
            let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
            if let router = router, router.responds(to: selector) {
                router.perform(selector, with: segue)
            }
        }
    }
    
    // MARK: View lifecycle
    
    override func viewDidLoad()
    {
        super.viewDidLoad()
        
        self.collectionView.register(UINib(nibName: "SectionCollectionViewCell", bundle: nil), forCellWithReuseIdentifier: "sectionMEGACell")
        
        self.collectionView.register(UINib(nibName: "DetailCollectionViewCell", bundle: nil), forCellWithReuseIdentifier: "detailCell")
        self.collectionView.register(UINib(nibName: "PeopleCollectionViewCell", bundle: nil), forCellWithReuseIdentifier: "peopleCell")
        self.collectionView.register(UINib(nibName: "PlotCollectionViewCell", bundle: nil), forCellWithReuseIdentifier: "plotCell")
        self.collectionView.register(UINib(nibName: "TitleCollectionViewCell", bundle: nil), forCellWithReuseIdentifier: "titleCell")
        self.collectionView.register(UINib(nibName: "SubsectionCollectionViewCell", bundle: nil), forCellWithReuseIdentifier: "subsectionCell")
        self.collectionView.register(UINib(nibName: "EpisodeCell", bundle: nil), forCellWithReuseIdentifier: "episodeCell")
        
        if let flowLayout = collectionView.collectionViewLayout as? UICollectionViewFlowLayout {
            flowLayout.estimatedItemSize = CGSize(width: UIScreen.main.bounds.size.width-(8*2), height: 50)
        }
        
        requestData()
    }
    
    // MARK: Do something
    
    //@IBOutlet weak var nameTextField: UITextField!
    
    func requestData()
    {
        let request = TVShowDetails.DataFilling.Request()
        interactor?.requestData(request: request)
    }
    
    var show: TVShow?
    func displayData(viewModel: TVShowDetails.DataFilling.ViewModel)
    {
        show = viewModel.show
        
        var ar = [(Season, HideableDataSource<Episode>)]()
        for season in viewModel.show?.seasons ?? []{
            ar.append((season, HideableDataSource(items: season.episodes, hidden: true)))
        }
        seasonsAreaData = HideableDataSource(items: ar, hidden: true)
        collectionView.reloadData()
    }
    
    private var buttons = [Episode:UIButton]()
    private var titleCell : TitleCollectionViewCell?
    
    func displayShowLists(viewModel: TVShowDetails.ShowLists.ViewModel){
        switch viewModel.list {
        case .Watchlist:
            switch viewModel.status{
            case .In:
                titleCell?.topButton.setTitle("Remove from watchlist", for: .normal)
            case .Out:
                titleCell?.topButton.setTitle("Add to watchlist", for: .normal)
            }
        case .Watched:
            if viewModel.status == .In{
                let request = TVShowDetails.ShowLists.Request(list: .Watchlist, action: .Remove)
                interactor?.showLists(request: request)
            }
            switch viewModel.status{
            case .In:
                titleCell?.bottomButton.setTitle("Unwatched", for: .normal)
            case .Out:
                titleCell?.bottomButton.setTitle("Watched", for: .normal)
            }
            if viewModel.action != .RequestStatus{
                collectionView
                    .reloadItems(at: (seasonsAreaStartCell..<(seasonsAreaStartCell+seasonsAreaCount))
                        .map { IndexPath(row: $0, section: 0) })
            }
        }
    }
    func displayEpisodeLists(viewModel: TVShowDetails.EpisodeLists.ViewModel){
        if viewModel.list == .Watched{
            var title: String
            if viewModel.status == .In{
                title = "Unwatch"
            }
            else{
                title = "Watch"
            }
            buttons[viewModel.episode]?.setTitle(title, for: .normal)
            
            if viewModel.action != .RequestStatus{
                requestShowStatus(listName: .Watched)
            }
        }
    }
    
    func requestShowStatus(listName: ListName){
        let request = TVShowDetails.ShowLists.Request(list: listName, action: .RequestStatus)
        interactor?.showLists(request: request)
    }
    
    let seasonsAreaStartCell = 3
    var seasonsAreaData : HideableDataSource<(Season, HideableDataSource<Episode>)>?
    var seasonsAreaCount : Int{
        get{
            return (seasonsAreaData?.dataSource.count ?? 0) +
                (seasonsAreaData?.dataSource.reduce(0, { (sum, pair) in
                    sum + pair.1.dataSource.count
                }) ?? 0)
        }
    }
    func seasonsAreaIndexPaths(tag: Int) -> [IndexPath]{
        var indexPaths = [IndexPath]()
        var row = seasonsAreaStartCell
        if tag == -1{
            for s in seasonsAreaData?.items ?? []{
                indexPaths.append(IndexPath(row: row, section: 0))
                row += 1
                for _ in s.1.dataSource{
                    indexPaths.append(IndexPath(row: row, section: 0))
                    row += 1
                }
            }
        }
        else{
            for s in seasonsAreaData?.dataSource[..<tag] ?? []{
                row += 1
                for _ in s.1.dataSource{
                    row += 1
                }
            }
            row += 1
            for _ in seasonsAreaData?.dataSource[tag].1.items ?? [] {
                indexPaths.append(IndexPath(row: row, section: 0))
                row += 1
            }
        }
        return indexPaths
    }
    
    var castCellIndex : Int{
        get{
            if (show?.cast.count ?? 0) > 0{
                return seasonsAreaStartCell+seasonsAreaCount
            }
            return -1
        }
    }
    
    var crewCellIndex : Int{
        get{
            if (show?.crew.count ?? 0) > 0{
                if castCellIndex < 0{
                    return castCellIndex
                }
                return castCellIndex + 1
            }
            return 0
        }
    }
    
    var detailCellStart : Int {
        get{
            return seasonsAreaStartCell+seasonsAreaCount + (crewCellIndex > 0 ? 1 : 0) + (castCellIndex > 0 ? 1 : 0)
        }
    }
}

extension TVShowDetailsViewController : UICollectionViewDelegate, UICollectionViewDataSource{
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int{
        if let _ = show{
            return seasonsAreaStartCell + seasonsAreaCount + (crewCellIndex > 0 ? 1 : 0) + (castCellIndex > 0 ? 1 : 0) + (show?.details.count ?? 0)
        }
        else{
            return 0
        }
    }
    
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell{
        switch indexPath.row {
        case 0:
            if let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "titleCell", for: indexPath) as? TitleCollectionViewCell, let show = self.show{
                cell.topButton.addTarget(self, action: #selector(topButtonPressed(_:)), for: .touchUpInside)
                cell.bottomButton.addTarget(self, action: #selector(bottomButtonPressed(_:)), for: .touchUpInside)
                
                cell.fill(filler: show)
                
                titleCell = cell
                
                requestShowStatus(listName: .Watchlist)
                requestShowStatus(listName: .Watched)
                
                return cell
            }
            
        case 1:
            if let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "plotCell", for: indexPath) as? PlotCollectionViewCell, let show = show{
                cell.fill(filler: show)
                return cell
            }
            
        case 2:
            if let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "sectionMEGACell", for: indexPath) as? SectionCollectionViewCell{
                cell.label.text = "Seasons"
                
                let transform = (seasonsAreaData?.hidden ?? true) ? CGFloat.pi : 0
                cell.hideButton.transform = CGAffineTransform(rotationAngle: transform)
                cell.hideButton.tag = -1
                cell.hideButton.removeTarget(nil, action: nil, for: .allEvents)
                cell.hideButton.addTarget(self, action: #selector(hideButtonPressed(_:)), for: .touchUpInside)
                return cell
            }
        case seasonsAreaStartCell..<seasonsAreaCount+seasonsAreaStartCell:
            var index = indexPath.row - seasonsAreaStartCell
            var season = 0
            var episode = -1
            for s in seasonsAreaData?.dataSource ?? [] {
                if index > s.1.dataSource.count {
                    index -= s.1.dataSource.count+1
                    season += 1
                    episode = -1
                }
                else{
                    episode = -1 + index
                    break
                }
            }
            
            if episode == -1{
                guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "subsectionCell", for: indexPath) as? SubsectionCollectionViewCell else {return UICollectionViewCell() }
                
                cell.label.text = seasonsAreaData?.dataSource[season].0.name
                
                let transform = (seasonsAreaData?.dataSource[season].1.hidden ?? true) ? CGFloat.pi : 0
                cell.hideButton.transform = CGAffineTransform(rotationAngle: transform)
                cell.hideButton.tag = season
                cell.hideButton.removeTarget(nil, action: nil, for: .allEvents)
                cell.hideButton.addTarget(self, action: #selector(hideButtonPressed(_:)), for: .touchUpInside)
                
                return cell
            }
            else{
                guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "episodeCell", for: indexPath) as? EpisodeCell else {return UICollectionViewCell() }
                
                if let item = seasonsAreaData?.dataSource[season].1.dataSource[episode] {
                    cell.episodeNumberLabel.text = "Episode \(item.episodeNumber)"
                    cell.titleLabel.text = item.name
                    cell.airDateLabel.text = item.dateString(format: "dd.mm.yyyy")
                    
                    cell.watchButton.removeTarget(nil, action: nil, for: .allEvents)
                    cell.watchButton.addTarget(self, action: #selector(watchEpisodeButtonPressed(_:)), for: .touchUpInside)
                    let tag = season * 10000 + episode
                    cell.watchButton.tag = tag
                    buttons[item] = cell.watchButton
                    let request = TVShowDetails.EpisodeLists.Request(list: .Watched, action: .RequestStatus, episode: item)
                    interactor?.episodeLists(request: request)
                }               
                
                return cell
            }
        case castCellIndex:
            if let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "peopleCell", for: indexPath) as? PeopleCollectionViewCell{
                
                cell.sectionTitleLabel.text = "Cast"
                
                if let show = show{
                    cell.people = show.cast
                }
                
                return cell
            }
            
        case crewCellIndex:
            if let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "peopleCell", for: indexPath) as? PeopleCollectionViewCell{
                
                cell.sectionTitleLabel.text = "Crew"
                
                if let show = show{
                    cell.people = show.crew
                }
                return cell
            }
        case detailCellStart..<(detailCellStart+(show?.details.count ?? 0)):
            if let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "detailCell", for: indexPath) as? DetailCollectionViewCell{
                if let details = show?.details{
                    cell.nameLabel.text = details[indexPath.row - detailCellStart].0
                    cell.valueLabel.text = details[indexPath.row - detailCellStart].1
                }
                return cell
            }
            
        default:
            return UICollectionViewCell()
        }
        return UICollectionViewCell()
    }
    
    @objc func topButtonPressed(_ sender: Any){
        let request = TVShowDetails.ShowLists.Request(list: .Watchlist, action: .Change)
        interactor?.showLists(request: request)
    }
    
    @objc func bottomButtonPressed(_ sender: Any){
        let request = TVShowDetails.ShowLists.Request(list: .Watched, action: .Change)
        interactor?.showLists(request: request)
    }
    
    @objc func watchEpisodeButtonPressed(_ sender: Any){
        if let sender = sender as? UIButton{
            let ep = sender.tag % 10000
            let se = sender.tag / 10000
            let episode = seasonsAreaData?.dataSource[se].1.dataSource[ep]
            
            if let episode = episode{
                buttons[episode] = sender
                
                let request = TVShowDetails.EpisodeLists.Request(list: .Watched, action: .Change, episode: episode)
                interactor?.episodeLists(request: request)
            }
        }
    }
    
    @objc func hideButtonPressed(_ sender: Any){
        if let sender = sender as? UIButton{
            guard let seasonsAreaData = seasonsAreaData else {return}
            let tag = sender.tag
            let ip = seasonsAreaIndexPaths(tag: tag)
            switch tag{
            case -1:
                if seasonsAreaData.hidden{
                    seasonsAreaData.toggle()
                    collectionView.insertItems(at: ip)
                }
                else{
                    seasonsAreaData.toggle()
                    collectionView.deleteItems(at: ip)
                }
                UIView.animate(withDuration: 0.25){
                    sender.transform = sender.transform.rotated(by: CGFloat.pi)
                }
            default:
                if tag >= 0 && tag < (seasonsAreaData.dataSource.count){
                    if seasonsAreaData.dataSource[tag].1.hidden{
                        seasonsAreaData.dataSource[tag].1.toggle()
                        collectionView.insertItems(at: ip)
                    }
                    else{
                        seasonsAreaData.dataSource[tag].1.toggle()
                        collectionView.deleteItems(at: ip)
                    }
                    UIView.animate(withDuration: 0.25){
                        sender.transform = sender.transform.rotated(by: CGFloat.pi)
                    }
                }
            }
        }
    }
}
