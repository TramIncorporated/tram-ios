//
//  WatchlistSceneViewController.swift
//  Tram
//
//  Created by Roman Abuzyarov on 22.03.2018.
//  Copyright (c) 2018 Tram, inc.. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol WatchlistSceneDisplayLogic: class
{
    func displayUser(viewModel: WatchlistScene.GetUser.ViewModel)
}

class WatchlistSceneViewController: UIViewController, WatchlistSceneDisplayLogic
{
    
    @IBOutlet weak var segmentedControl: UISegmentedControl!
    
    
    var interactor: WatchlistSceneBusinessLogic?
    var router: (NSObjectProtocol & WatchlistSceneRoutingLogic & WatchlistSceneDataPassing)?
    
    @IBAction func segmentedChanged(_ sender: Any) {
        if let sender = sender as? UISegmentedControl{
            switch sender.selectedSegmentIndex{
            case 0:
                scope = .Movie
            case 1:
                scope = .TVShow
            default:
                ()
            }
            collectionView.reloadData()
        }
    }
    @IBOutlet weak var collectionView: UICollectionView!
    
    // MARK: Object lifecycle
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)
    {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder)
    {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: Setup
    
    private func setup()
    {
        let viewController = self
        let interactor = WatchlistSceneInteractor()
        let presenter = WatchlistScenePresenter()
        let router = WatchlistSceneRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    
    // MARK: Routing
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?)
    {
        if let scene = segue.identifier {
            let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
            if let router = router, router.responds(to: selector) {
                router.perform(selector, with: segue)
            }
        }
    }
    
    // MARK: View lifecycle
    
    override func viewDidLoad()
    {
        super.viewDidLoad()
        
        self.collectionView?.register(UINib(nibName: "ListMovieCell", bundle: nil), forCellWithReuseIdentifier: "movieCell")
        self.collectionView?.register(UINib(nibName: "EpisodeCell", bundle: nil), forCellWithReuseIdentifier: "episodeCell")
        self.collectionView?.register(UINib(nibName: "HideableShowCollectionReusableView", bundle: nil), forSupplementaryViewOfKind: UICollectionElementKindSectionHeader, withReuseIdentifier: "hideableCell")
        
        let blue = UIColor(red: 50.0/255, green: 85.0/255, blue: 219.0/255, alpha: 1)
        let gray = UIColor.black
        let font = UIFont(name: "HelveticaNeue-Thin", size: 16.0)!
        var attributes = [NSAttributedStringKey.foregroundColor : blue,
                          NSAttributedStringKey.font : font]
        segmentedControl.setTitleTextAttributes(attributes, for: .selected)
        attributes = [NSAttributedStringKey.foregroundColor : gray,
                      NSAttributedStringKey.font : font]
        segmentedControl.setTitleTextAttributes(attributes, for: .normal)
    }
    
    override func viewWillAppear(_ animated: Bool) {
        getUser()
    }
    
    func getUser()
    {
        let request = WatchlistScene.GetUser.Request()
        interactor?.getUser(request: request)
    }
    
    func displayUser(viewModel: WatchlistScene.GetUser.ViewModel)
    {
        user = viewModel.user
        let bools = episodes.map { $0.hidden }
        episodes.removeAll()
        for i in 0..<(user?.showWatchlist ?? []).count {
            let hidden = i < bools.count ? bools[i] : true
            episodes.append(HideableDataSource(items: unwatchedEpisodesCurrentSeason(index: i), hidden: hidden))
        }
        
        collectionView.reloadData()
    }
    
    var episodes = [HideableDataSource<Episode>]()
    var user : User?
    func unwatchedEpisodesCurrentSeason(index: Int) -> [Episode]{
        guard let tvshow = user?.showWatchlist?[index] else { return [] }
        let watched = user?.showWatchedDictionary?["\(tvshow.id)"]?.map { (s) -> (Int, Int) in
            let pair = s.components(separatedBy: ["_"])
            let season = Int(pair[0])!
            let episode = Int(pair[1])!
            return (season, episode)
        } ?? []
        
        for season in tvshow.seasons.sorted(by: {$0.seasonNumber < $1.seasonNumber}){
            if season.seasonNumber == 0 {
                continue
            }
            let watchedInSeason = watched.filter { $0.0 == season.seasonNumber }.map { $0.1 }
            if season.episodes.count <= watchedInSeason.count{
                continue
            }
            return season.episodes
                .filter { !watchedInSeason.contains($0.episodeNumber) }
                .sorted { $0.episodeNumber < $1.episodeNumber }
        }
        let special = tvshow.seasons[0]
        let watchedInSeason = watched.filter { $0.0 == special.seasonNumber }.map { $0.1 }
        return special.episodes
            .filter { !watchedInSeason.contains($0.episodeNumber) }
            .sorted { $0.episodeNumber < $1.episodeNumber }
    }
    
    enum Scope{
        case Movie
        case TVShow
    }
    
    var scope = Scope.Movie
}

extension WatchlistSceneViewController : UICollectionViewDelegate, UICollectionViewDataSource, UICollectionViewDelegateFlowLayout{
    func numberOfSections(in collectionView: UICollectionView) -> Int {
        if let user = user{
            switch scope {
            case .Movie:
                return 1
            case .TVShow:
                return user.showWatchlist?.count ?? 0
            }
        }
        return 0
    }
    
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        if let user = user{
            switch scope{
            case .Movie:
                return user.movieWatchlist?.count ?? 0
            case .TVShow:
                return episodes[section].dataSource.count
            }
        }
        return 0
    }
    
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        switch scope {
        case .Movie:
            guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "movieCell", for: indexPath) as? ListMovieCell else {return UICollectionViewCell()}
            guard let item = user?.movieWatchlist?[indexPath.row] else {return UICollectionViewCell()}
            
            cell.titleLabel.text = item.title
            cell.yearLabel.text = item.year
            cell.ratingLabel.text = item.rating
            cell.watchButton.tag = indexPath.row
            cell.watchButton.addTarget(self, action: #selector(movieWatchedPressed(_:)), for: .touchUpInside)
            cell.lengthLabel.text = item.cast
                .sorted {$0.order<$1.order}
                .prefix(2)
                .filter { $0.name != nil }
                .map { $0.name! }
                .joined(separator: ", ")
            
            cell.id = item.id
            cell.resetImage()
            ImageCacheManager.getImageInBackground(url: URL(string: item.imageUrl), onComplete: { (image) in
                cell.imageView.layer.borderWidth = 0
                if cell.id == item.id{
                    cell.imageView.image = image
                }
            })
            return cell
        case .TVShow:
            guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "episodeCell", for: indexPath) as? EpisodeCell else {return UICollectionViewCell()}
            let item = episodes[indexPath.section].dataSource[indexPath.row]
            
            cell.titleLabel.text = item.name
            cell.episodeNumberLabel.text = "S\(item.seasonNumber)E\(item.episodeNumber)"
            cell.airDateLabel.text = item.dateString(format: "dd.mm.yyyy")
            
            cell.watchButton.setTitle("Watch", for: .normal)
            cell.watchButton.tag = indexPath.section*10000+indexPath.row
            cell.watchButton.removeTarget(nil, action: nil, for: .allEvents)
            cell.watchButton.addTarget(self, action: #selector(watchPressed(_:)), for: .touchUpInside)
            
            return cell
        }
    }
    
    func collectionView(_ collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, at indexPath: IndexPath) -> UICollectionReusableView {
        guard let cell = collectionView.dequeueReusableSupplementaryView(ofKind: kind, withReuseIdentifier: "hideableCell", for: indexPath) as? HideableShowCollectionReusableView else { return UICollectionReusableView() }
        guard let item = user?.showWatchlist?[indexPath.section] else {return UICollectionReusableView()}
        switch scope {
        case .Movie:
            ()
        case .TVShow:
            cell.titleLabel.text = item.name
            cell.yearLabel.text = item.year
            cell.ratingLabel.text = item.rating
            cell.bottomLabel.text = item.cast
                .sorted {$0.order<$1.order}
                .prefix(2)
                .filter { $0.name != nil }
                .map { $0.name! }
                .joined(separator: ", ")
            
            cell.id = item.id
            cell.resetImage()
            ImageCacheManager.getImageInBackground(url: URL(string: item.imageUrl), onComplete: { (image) in
                cell.imageView.layer.borderWidth = 0
                if cell.id == item.id{
                    cell.imageView.image = image
                }
            })
            
            cell.hideButton.rotate(hidden: episodes[indexPath.section].hidden, animate: false)
            cell.hideButton.tag = indexPath.section
            cell.hideButton.removeTarget(nil, action: nil, for: .allEvents)
            cell.hideButton.addTarget(self, action: #selector(hidePressed(_:)), for: .touchUpInside)
        }
        
        return cell
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        let width = UIScreen.main.bounds.width - (8*2)
        switch scope {
        case .Movie:
            return CGSize(width: width, height: 100)
        case .TVShow:
            return CGSize(width: width, height: 50)
        }
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, referenceSizeForHeaderInSection section: Int) -> CGSize {
        let width = UIScreen.main.bounds.width - (8*2)
        switch scope {
        case .Movie:
            return CGSize(width: width, height: 0)
        case .TVShow:
            return CGSize(width: width, height: 100)
        }
    }
    
    @objc func hidePressed(_ sender: Any){
        if let sender = sender as? UIButton{
            let section = sender.tag
            let ip = episodes[section].indexPaths(for: section)
            if episodes[section].hidden{
                episodes[section].toggle()
                collectionView.insertItems(at: ip)
            }
            else{
                episodes[section].toggle()
                collectionView.deleteItems(at: ip)
            }
            sender.rotate(animate: true)
        }
    }
    
    @objc func movieWatchedPressed(_ sender: Any){
        if let sender = sender as? UIButton{
            let i = sender.tag
            
            if let movie = user?.movieWatchlist?[i]{
                LocalWorker().list(do: .Add, movie: movie, in: .Watched, onSuccess: { (l, s, a) in
                })
                LocalWorker().list(do: .Remove, movie: movie, in: .Watchlist, onSuccess: { (l, s, a) in
                    getUser()
                })
            }
        }
    }
    
    @objc func watchPressed(_ sender: Any){
        if let sender = sender as? UIButton{
            let sec = sender.tag / 10000
            let row = sender.tag % 10000
            
            let episode = episodes[sec].dataSource[row]
            LocalWorker().list(do: .Add, episode: episode, in: .Watched, onSuccess: { (l, s, a) in
                getUser()
            })
        }
    }
}

